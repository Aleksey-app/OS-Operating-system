# Практическая работа №8
**Знакомство с механизмом взаимодействия удаленных процессов – сокетами и с системными вызовами, обеспечивающими установление соединения, разъединение, а также передачу и прием данных.**
>Написать комплект из двух программ, одна из которых выполняет функции сервера, а вторая выполняет функции клиента.
Клиент, после установления соединения с сервером, посылает серверу запросы с периодом 1 сек.
Сервер принимает запросы, обрабатывает их и отправляет ответы клиенту. Под обработкой будем понимать выполнение функции, ранее выбранной для других работ. Клиент принимает ответы и выводит их на экран.


С каждым сокет связываются три атрибута: домен, тип и протокол. Эти атрибуты задаются при создании сокета и остаются неизменными на протяжении всего времени его существования. Для создания сокета используется функция socket, имеющая следующий прототип.
```c
int socket(int domain, int type, int protocol);
```
- Где: domain - определяет тип коммуникационного протокола;
    |Тип|Описание|
    |:--|:------:|
    |AF_UNIX|Локальные сокеты для передачи данных используется файловая система ввода/вывода Unix|
    |AF_INET|Cокеты протокола интернет. Сокеты, размещённые в этом домене, могут использоваться для работы в любой IP-сети|
    |AF_IPX|Для протоколов Novell|
    |AF_INET6|Cокеты протокола интернет. IPv6|
- type –	определяет тип передачи;
    |Флаг|Описание|
    |:---|:------:|
    |SOCK_STREAM|Передача потока данных с предварительной установкой соединения. Обеспечивается надёжный канал передачи данных, при котором фрагменты отправленного блока не теряются, не переупорядочиваются и не дублируются|
    |SOCK_DGRAM|Передача данных в виде отдельных сообщений (датаграмм). Предварительная установка соединения не требуется. Обмен данными происходит быстрее, но является ненадёжным: сообщения могут теряться в пути, дублироваться и переупорядочиваться|
    |SOCK_RAW|Этот тип присваивается низкоуровневым (т. н. "сырым") сокетам. Их отличие от обычных сокетов состоит в том, что с их помощью программа может взять на себя формирование некоторых заголовков, добавляемых к сообщению|
- protocol - определяет протокол, используемый для передачи данных. Можно передать 0, что соответствует протоколу по умолчанию. 

**Для явного связывания сокета с некоторым адресом используется функция**
```c
int bind(int sockfd, struct sockaddr *addr, int addrlen);
```
- Где: sockfd - дескриптор сокета;
- addr - содержит указатель на структуру с адресом;
```c
struct sockaddr {
    unsigned short    sa_family;    // Семейство адресов, AF_xxx
    char              sa_data[14];  // 14 байтов для хранения адреса
};
```
Поле sa_family содержит идентификатор домена, тот же, что и первый параметр функции socket. В зависимости от значения этого поля по-разному интерпретируется содержимое массива sa_data. Разумеется, работать с этим массивом напрямую не очень удобно, поэтому вы можете использовать вместо sockaddr одну из альтернативных структур вида sockaddr_XX (XX - суффикс, обозначающий домен: "un" - Unix, "in" - Internet и т. д.). 
```c
struct sockaddr_in {
    short int          sin_family;  // Семейство адресов
    unsigned short int sin_port;    // Номер порта
    struct in_addr     sin_addr;    // IP-адрес
    unsigned char      sin_zero[8]; // "Дополнение" до размера структуры sockaddr
};
```
Здесь поле sin_family соответствует полю sa_family в sockaddr, в sin_port записывается номер порта, а в sin_addr - IP-адрес хоста. Поле sin_addr само является структурой, которая имеет вид:
```c
struct in_addr {
    unsigned long s_addr;
};
```
  &#9989;При указании IP-адреса и номера порта необходимо преобразовать число из порядка хоста в сетевой. Для этого используются функции ```htons (Host TO Network Short)``` и ```htonl (Host TO Network Long)```. Обратное преобразование выполняют функции ```ntohs``` и ```ntohl```.
